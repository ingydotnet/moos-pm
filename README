NAME
    Moos - Moo s{imple,peedy,ingle}

SYNOPSIS
        package Foos;
        use Moos;

        extends 'Boos';

        has this => ();
        has that => 42;
        has other => (
            builder => 'build_other',
            lazy => 1,
        );

        sub BUILD {
            my $self = shift;
            # build, build, build
        }

        sub BUILDARGS {
            my ($self, @args) = @_;
            # munge, munge, munge
            return {%munged_args};
        }

DESCRIPTION
    Moos completes the M to Moose sequence of Perl OO modules.

    This one is pure Perl, no dependencies, single file and Moose compatible
    (for what it does).

FEATURES
    Here's a quick list of the Moose compatible features that are supported
    by Moos:

    strict / warnings
        Turns on "strict" and "warnings" for you.

    extends
        For inheritance. "Moos::Object" is the default base class.

            package MyClass;
            extends 'MyBaseClass';

        Supports multiple inheritance, by allowing multiple classes on a
        single invocation.

    new A constructor class method.

            my $object = MyClass->new(this => 'nice', that => 2);

    BUILD
        Custom object construction. If you define BUILD, it is passed the
        value of the new object during construction. You can modify the
        object. Any value you return is ignored.

            sub BUILD { my $self = shift; ... }

    Helpful exports
        The ever useful "blessed" (from Scalar::Util) and "confess" (from
        Carp) are exported to your namespace.

    has Accessor generator. Supports the "is", "default", "build", "lazy",
        "clearer", "predicate", "required" and "handles" options, described
        below.

            has this => ();

        NOTE: Class::XSACcessor will be used for simple accessors if it is
        installed. This can be disabled by setting $Moos::CAN_HAZ_XS to
        false or by setting the PERL_MOOS_XS_DISABLE to true.

    is  Specify which type of attribute accessor to provide. The default is
        "rw", a read-write accessor. Read-only "ro" accessors are also
        supported.

            has this => ( is => "ro" );

    default
        Specify the sub to generate a default value.

            has this => ( default => sub { 42 } );

    builder
        Specify the method name to generate a default value.

            has this => ( builder => '_build_this' );
            has that => ( builder => 1 );  # accept default name for method

    lazy
        Don't generate defaults during object construction.

            has this => ( builder => '_build_this', lazy => 1 );

    clearer
        Creates a clearer method.

            has this => ( clearer => "clear_this" );
            has that => ( clearer => 1 );  # accept default name for method

    predicate
        Creates a predicate method, which can be used to check if the
        attribute is set or unset.

            has this => ( predicate => "has_this" );
            has that => ( predicate => 1 );  # accept default name for method

    required
        Require that a value for the attribute be provided to the
        constructor or generated during object construction.

            has this => ( required => 1 );

    handles
        Delegated method calls.

            has wheels => (handles => [qw/ roll /]);

        This accepts a hashref or arrayref, but not the other possibilities
        offered by Moose.

    Note that currently all accessors are read-write by default and all
    unknown options are silently ignored.

HAS DIFFERENCES
    Moos has a few differences from Moose, regarding it's accessor support
    (ie the 'has' function).

    The supported options detailed above are about the same as Moose. All
    other arguments are currently ignored. All generated accessors are 'rw'.
    So you can just say:

        has 'this';
        has that => ();

    Unlike the other Mo* modules, Moos also supports just specifying the
    default. If the number of arguments (after the name) is an odd number,
    then the first value is the default. The following forms are valid:

        has a => 42;
        has b => 'string' => (lazy => 1);
        has c => {};
        has d => [1, 2, 3, 4];

    These all result in creating a Moos "default" argument. If the default
    is an array or hash reference, a shallow copy is made.

DEV OPTIONS
    Moos has a couple builtin dev options. They are controlled by
    environment variables.

    PERL_MOOS_ACCESSOR_CALLS
        By setting this environment variable, Moos will warn everytime an
        accessor method is called.

    PERL_MOOS_XXX
        By setting the environment variable, Moos will export the XXX
        debugging keywords.

WHENCE
    I(ngy) created Moos during Pegex development. Pegex uses a clone of Moos
    called Pegex::Base.

    Pegex is a parser framework and needs to be fast. While looking into
    speed issues I noted that accessor calling was the biggest hit. I tried
    all the various Mo* solutions and Mouse was the fastest.

    I was happy until I remembered that Mouse uses XS, and for various
    reasons this broke my toolchain (TestML, Module::Install, etc).

    I tried to inline Moo into one file but failed, and ended up with this.
    I've shared Pegex::Base as Moos in case any other projects want it.

    Later on, Toby added a bunch of low-cost but very features from Moose.

ON SPEED
    In the end, I got Pegex to run even faster with Moos than it originally
    did with Mouse. I'll tell you my secret...

    <Accessors *(usually)* do not need to be method calls.>

    Replace these:

        my $foo = $self->foo;
        $self->foo($foo);

    with:

        my $foo = $self->{foo};
        $self->{foo} = $foo;

    And your code will be faster (and a bit uglier).

    The only time that you need to call an accessor method is when you are
    reading a property and it might invoke a "lazy" "builder" or "default"
    method. Otherwise you are just wasting time. At least with the minimal
    feature set offered by Moos.

    The PERL_MOOS_ACCESSOR_CALLS feature described above is for finding
    these method calls.

    Note that users of your module's accessor methods can still use the
    method calls like they would expect to.

    I'm sure I've missed some subtlties, and would be glad to hear opinions,
    but in the meantime I'm happy that my code is faster and pure Perl.

SEE ALSO
    *   M

    *   Mo

    *   Moo

    *   Moos

    *   Moose

    *   Mouse

    *   Mousse

AUTHORS
    Ingy döt Net <ingy@cpan.org>

    Toby Inkster <tobyink@cpan.org>

COPYRIGHT AND LICENSE
    Copyright (c) 2012. Ingy döt Net.

    This program is free software; you can redistribute it and/or modify it
    under the same terms as Perl itself.

    See http://www.perl.com/perl/misc/Artistic.html

