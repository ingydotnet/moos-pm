NAME
    Moos - Moo s{imple,peedy,ingle}

SYNOPSIS
        package Foos;
        use Moos;

        extends 'Boos';

        has this => ();
        has that => (default => sub { 42 });
        has other => (
            builder => 'build_other',
            lazy => 1,
        );

        sub BUILD {
            my $self = shift;
            # build, build, build
        }

DESCRIPTION
    Moos completes the M to Moose sequence of Perl OO modules.

    This one is pure Perl, no dependencies, single file and Moose compatible
    (for what it does). It is fairly minimal; it supports the features shown
    in the SYNOPSIS.

FEATURES
    Here's a quick list of the Moose compatible features that are supported
    by Moos:

    extends
        For inheritance. "Moos::Object" is the default base class.

            package MyClass;
            extends 'MyBaseClass';

    new A constructor class method.

            my $object = MyClass->new(this => 'nice', that => 2);

    BUILD
        Custom object construction. If you define BUILD, it is passed the
        value of the new object during construction. You can modify the
        object. Any value you return is ignored.

            sub BUILD { my $self = shift; ... }

    has Accessor generator. Supports the "default", "build" and "lazy"
        options, described below.

            has this => ();

    default
        Specify the sub to generate a default value.

            has this => ( default => sub { 42 } );

    builder
        Specify the method name to generate a default value.

            has this => ( builder => 'build_this' );

    lazy
        Don't generate defaults during object construction.

            has this => ( builder => 'build_this', lazy => 1 );

    Note that currently all accessors are read-write, and the "is" keyword
    is silently ignored (as are all other unknown keywords).

HAS DIFFERENCES
    Moos has a few differences from Moose, regarding it's accessor support
    (ie the 'has' function).

    Support for "default", "builder" and "lazy" are about the same. All
    other arguments are currently ignored, including the "is" property. All
    generated accessors are 'rw'. So you can just say:

        has 'this';
        has that => ();

    Unlike the other Mo* modules, Moos also supports just sepcifiying the
    default. If the number of arguments (after the name) is an odd number,
    then the first value is the default. The following forms are valid:

        has a => 42;
        has b => 'string' => (lazy => 1);
        has c => {};
        has d => [1, 2, 3, 4];

    These all result in creating a Moos "default" argument. If the default
    is an array or hash reference, a shallow copy is made.

DEV OPTIONS
    Moos has a couple builtin dev options. They are controlled by
    environment variables.

    PERL_MOOS_ACCESSOR_CALLS
        By setting this environment variable, Moos will warn everytime an
        accessor method is called.

    PERL_MOOS_XXX
        By setting the environment variable, Moos will export the XXX
        debugging keywords.

WHENCE
    I(ngy) created Moos during Pegex development. Pegex uses a clone of Moos
    called Pegex::Base.

    Pegex is a parser framework and needs to be fast. While looking into
    speed issues I noted that accessor calling was the biggest hit. I tried
    all the various Mo* solutions and Mouse was the fastest.

    I was happy until I remembered that Mouse uses XS, and for various
    reasons this broke my toolchain (TestML, Module::Install, etc).

    I tried to inline Moo into one file but failed, and ended up with this.
    I've shared Pegex::Base as Moos in case any other projects want it.

ON SPEED
    In the end, I got Pegex to run even faster with Moos than it originally
    did with Mouse. I'll tell you my secret...

    <Accessors *(usually)* do not need to be method calls.>

    Replace these:

        my $foo = $self->foo;
        $self->foo($foo);

    with:

        my $foo = $self->{foo};
        $self->{foo} = $foo;

    And your code will be faster (and a bit uglier).

    The only time that you need to call an accessor method is when you are
    reading a property and it might invoke a "lazy" "builder" or "default"
    method. Otherwise you are just wasting time. At least with the minimal
    feature set offered by Moos.

    The PERL_MOOS_ACCESSOR_CALLS feature described above is for finding
    these method calls.

    Note that users of your module's accessor methods can still use the
    method calls like they would expect to.

    I'm sure I've missed some subtlties, and would be glad to hear opinions,
    but in the meantime I'm happy that my code is faster and pure Perl.

SEE ALSO
    *   M

    *   Mo

    *   Moo

    *   Moos

    *   Moose

    *   Mouse

    *   Mousse

AUTHOR
    Ingy döt Net <ingy@cpan.org>

COPYRIGHT AND LICENSE
    Copyright (c) 2012. Ingy döt Net.

    This program is free software; you can redistribute it and/or modify it
    under the same terms as Perl itself.

    See http://www.perl.com/perl/misc/Artistic.html

